<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
<title>MARS FUTURE AI - TEST</title>

<style>
html, body {
  margin: 0;
  padding: 0;
  overflow: hidden;
  background: #050505;
}

canvas {
  display: block;
  touch-action: none;
}
</style>
</head>

<body>
<canvas id="game"></canvas>

<script>
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");

function resize() {
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
}
window.addEventListener("resize", resize);
resize();

/* =========================
   GAME STATE
========================= */
let score = 0;
let gameTime = 0;

const player = {
  x: canvas.width / 2,
  y: canvas.height * 0.8,
  size: 18,
  hp: 100
};

let bullets = [];
let enemies = [];
let enemyBullets = [];
let boss = null;

/* =========================
   INPUT (MOBILE)
========================= */
let touchX = null;
let touchY = null;

canvas.addEventListener("touchstart", e => {
  const t = e.touches[0];
  touchX = t.clientX;
  touchY = t.clientY;
});

canvas.addEventListener("touchmove", e => {
  const t = e.touches[0];
  touchX = t.clientX;
  touchY = t.clientY;
  e.preventDefault();
}, { passive: false });

canvas.addEventListener("touchend", () => {
  touchX = null;
  touchY = null;
});

/* =========================
   PLAYER BULLET
========================= */
setInterval(() => {
  bullets.push({
    x: player.x,
    y: player.y,
    r: 4,
    dmg: 20
  });
}, 200);

/* =========================
   ENEMY SPAWN
========================= */
setInterval(() => {
  if (!boss) {
    enemies.push({
      x: Math.random() * canvas.width,
      y: -30,
      size: 16,
      hp: 40,
      speed: 2 + score * 0.002
    });
  }
}, 800);

/* =========================
   BOSS SPAWN
========================= */
function spawnBoss() {
  boss = {
    x: canvas.width / 2,
    y: 120,
    r: 50,
    maxHp: 5000 + Math.min(score * 5, 5000),
    hp: 5000 + Math.min(score * 5, 5000),
    phase: 1,
    cooldown: 0
  };
}

setInterval(() => {
  if (!boss && score > 1000) spawnBoss();
}, 2000);

/* =========================
   GAME LOOP
========================= */
function update() {
  gameTime++;

  /* Player move */
  if (touchX !== null) {
    player.x += (touchX - player.x) * 0.15;
    player.y += (touchY - player.y) * 0.15;
  }

  /* Bullets */
  bullets = bullets.filter(b => {
    b.y -= 10;
    return b.y > 0;
  });

  /* Enemies */
  enemies = enemies.filter(e => {
    e.y += e.speed;

    bullets.forEach((b, i) => {
      if (Math.hypot(b.x - e.x, b.y - e.y) < e.size) {
        e.hp -= b.dmg;
        bullets.splice(i, 1);
      }
    });

    if (e.hp <= 0) {
      score += 100;
      return false;
    }

    return e.y < canvas.height;
  });

  /* Boss logic */
  if (boss) {
    if (boss.hp < boss.maxHp * 0.5) boss.phase = 2;

    // simple evade
    boss.x += Math.sin(gameTime * 0.05) * (boss.phase === 2 ? 4 : 2);

    boss.cooldown--;
    if (boss.cooldown <= 0) {
      const angleStep = boss.phase === 2 ? 20 : 40;
      for (let a = 0; a < 360; a += angleStep) {
        const rad = a * Math.PI / 180;
        enemyBullets.push({
          x: boss.x,
          y: boss.y,
          vx: Math.cos(rad) * 3,
          vy: Math.sin(rad) * 3
        });
      }
      boss.cooldown = boss.phase === 2 ? 40 : 80;
    }

    bullets.forEach((b, i) => {
      if (Math.hypot(b.x - boss.x, b.y - boss.y) < boss.r) {
        boss.hp -= b.dmg;
        bullets.splice(i, 1);
      }
    });

    if (boss.hp <= 0) {
      boss = null;
      score += 2000;
    }
  }

  /* Enemy bullets */
  enemyBullets = enemyBullets.filter(b => {
    b.x += b.vx;
    b.y += b.vy;

    if (Math.hypot(b.x - player.x, b.y - player.y) < player.size) {
      player.hp -= 10;
      return false;
    }

    return b.x > 0 && b.x < canvas.width && b.y > 0 && b.y < canvas.height;
  });
}

/* =========================
   DRAW
========================= */
function draw() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  // Player
  ctx.fillStyle = "#4af";
  ctx.fillRect(player.x - player.size/2, player.y - player.size/2, player.size, player.size);

  // Bullets
  ctx.fillStyle = "#fff";
  bullets.forEach(b => {
    ctx.beginPath();
    ctx.arc(b.x, b.y, b.r, 0, Math.PI * 2);
    ctx.fill();
  });

  // Enemies
  ctx.fillStyle = "#f44";
  enemies.forEach(e => {
    ctx.beginPath();
    ctx.arc(e.x, e.y, e.size, 0, Math.PI * 2);
    ctx.fill();
  });

  // Boss
  if (boss) {
    ctx.fillStyle = boss.phase === 2 ? "#ff0" : "#f0f";
    ctx.beginPath();
    ctx.arc(boss.x, boss.y, boss.r, 0, Math.PI * 2);
    ctx.fill();

    // Boss HP bar
    ctx.fillStyle = "#400";
    ctx.fillRect(20, 20, canvas.width - 40, 10);
    ctx.fillStyle = "#f00";
    ctx.fillRect(20, 20, (canvas.width - 40) * (boss.hp / boss.maxHp), 10);
  }

  // Enemy bullets
  ctx.fillStyle = "#fa0";
  enemyBullets.forEach(b => {
    ctx.beginPath();
    ctx.arc(b.x, b.y, 4, 0, Math.PI * 2);
    ctx.fill();
  });

  // UI
  ctx.fillStyle = "#fff";
  ctx.font = "14px monospace";
  ctx.fillText("SCORE: " + score, 20, canvas.height - 20);
  ctx.fillText("HP: " + player.hp, canvas.width - 100, canvas.height - 20);
}

/* =========================
   LOOP
========================= */
function loop() {
  update();
  draw();
  requestAnimationFrame(loop);
}

loop();
</script>
</body>
</html>
